 dia 19 de Abril
echo "luiz Henrique " > test.txt | wc -l | ls
	1 -> dividir toda a command line em palavras separadas por
	espaco. Tendo em vista que ha a possibilidade de usarmos
	as aspas para indicar apenas um argumento, eu tive de
	contornar essa adversidade para poder usar o split e simplificar
	toda a tokentization.
	2 -> dividir a command line em cada pipeline que existir. Assim
	separei os comandos que existem. Cada pipeline divide o command line
	em dois commandos.

Tudo isso feito, eu tenho dois arrays bidimensionais com as informacoes
que recebi. Eu agora precisarei percorrer minha string novamente e identificar
quais palavras sao comandos e assinalar o tipo de comando.
Com o que sei atualmente eu posso criar um dicionario de todos os comandos
existentes e criar um codigo para cada um para que possa assinala-lo a um tipo.
Portanto, ja irei comecar a criar tipos. Isso ficara limitado em um array_2d.
Para isso posso usar as informacoes que tenho para criar uma linked_list.


dia 20 de Abril
Estive a conversar com o Ezequiel e recebi varias dicas, entre elas:
- dentro das strings que recebo da funcao criada com o separador '|'
a primeira palavra eh sempre ou um command ou um Builtin.
- Tendo feito a divisao de tudo em palavras e em comandos. Agora,
eu preciso separar o que tenho em comandos e em seus respectivos argumentos dentro
de um array bidimensional. Isso seria tokentizar minha string recebida na command
line.
- Depois criarei uma linked list com as respectivas informacoes "    char		**args;
char		*gpath; int		fd[2]; int		in_fd; int		out_fd;
 struct s_token	*next;
	Devo considerar tudo buscar por redirecoes;



*Sabendo que a primeira palavra de cada um dos nossos comandos eh um builtin ou um
command e, tendo em vista, que os nossos Builtins sao uma lista menor de itens podemos
criar um dicionario com nossos builtin. O que nao for builtin possivelmente sera um
comando. Caso tenhamos alguma palavras escrita de forma errada na nossa funcao que
fornece o path retornara um NULL caso nao encontre.

dia 24 de Abril (segunda-feira)
na ultima sexta investi em aprender como criar uma binary tree. Contudo, acredito que
deveria ter feito o trabalho mais simples e implementado o que discuti com o Ezequiel.
Depois disso, vale a pena eu implementar melhorias no projeto e ate ajudar o Rodrigo com
a parte de execucao. Assim, poderei aprender sobre ambas as partes e ver como ele desenvolve.
Basicamente, eu tenho a seguinte command line e consigo dividir os comandos.


$ echo "luiz Henrique " > test.txt | wc -l | ls -la

[
	[echo"luiz Henrique ">test.txt],
	[wc, -l],
	[ls, -la],
]

Portanto, vou percorrer as minhas strings caso em encontre um separador
terei de quebrar a string daquele ponto ate o proximo separador.
Meu problema esta a ser com o array 2d, pois terei de inserir uma nova string.
Dessa forma, sera necessario criar um novo array com as novas dimensoes.
Na verdade, estive a pensar que seria mais facil lidar com esses desafios dentro
de uma linked list. Assim poderia acrescentar um node de forma mais simples e poderia
fazer isso multiplas vezes.

[
	[echo, "luiz Henrique "],
	[>, test.txt],
	[wc, -l],
	[ls, -la],
]

Outra situacao eh que eu teria de criar um dicionario indicar ao Rodrigo se
estamos a tratar um comando ou um builtin na caso especifico. Contudo, antes de
dificultar resolverei a situacao de forma simples e depois posso acrescentar camadas
de complexidade a mais.
Posso resolver isso apenas com comparacao de strings.


Dia 26 de abril

echo"luiz Henrique "
> test.txt
Na verdade, isso devera ser dividido em dois comandos. Portanto, dois nodes diferentes.

dia 29 de Abril de 2023
Estou em um ponto no qual ja estou a receber os input do user e
tratar disso da forma que eh devida. Separei os comandos e os argumentos dos
comandos de modo que consegui organizar devidamente dentro de um array bidimensional.
Consegui tambem localizar o path de cada dos comandos e caso nao haja path especifico
repassei o recebido no env.
Minha ideia agora sera criar um array de inteiros com todos os comandos que estamos e
criar uma funcao que me retornara um tipo ou uma string de referencia.
    void *capitalCities = new_hasmap();

    HashMap(capitalCities)->put("England", "London");


Dia 01 de Maio
Percebi que estava a lidar de forma equivocada com as quotes. Estava a aceitar a correspondencia
e combinacao de single com double e virse e versa. Isso estava errado. Foi facil perceber onde
estava o erro. Na verdade, devia checar se o meu char set era igual ao caracter de analise. Desse
modo ele teria de ser igual para receber completar o par.
Percebi que estava a retornar o path errado tambem, pois caso o path da variavel de ambiente
seja apagada com o unset ele estava a retornar NULL. Quando deveria retornar o valor recebido como
parametro. Resolver isso foi simples, pois na funcao gpath deveria retornar uma string com o commando
recebido.

Dia 03 de maio
Ontem sai daqui com uma mensagem de erro bastante estranha. Aparentemente, a minha funcao
split e/ou a minha funcao ft_substring estao a ter problemas em acessar espacos nao per-
mitidos de memoria. Portanto, isolei cada uma e mesmo ontem pude perceber que meu erro
nao estava propriamente dito no split.
Sai daqui com a impressao de que havia outra coisa, pois em casos em que
eu nao inseria o caracter 3 ou 2 o meu split criava um array_2d sem
encontrar o separador target.
Preciso isolar a funcao substring e


Dia 04 de Maio

Estou a procurar still reachable

Dia 08 de Maio
Ainda estou com os still reachable. Contudo, desenvolve os
signals que conectam o ctrl + c e ctrl + d para encerrar
o programa e poder perceber se ha leaks ou se estamos a
a administrar tudo como deve ser.
Estou a realizar a limpeza de toda a minha lista quando
clico em ctrl + d. Portanto, deveria estar a limpar toda
a memoria alocada. Contudo, ha ainda 214 alocamentos que
nao deveriam estar la que estao a ser identificados.
A falar com um colega que ja terminou esse projeto, fiquei
sabendo que onde dermos exit teremos de limpar a memoria para
nao termos still reachable.

Dia 10 de Maio
Ficou acertado com o Rodrigo que eu trataria das expansoes
e do export e ele cuidaria do infile e do heredoc.

tasks para minishell
- export
- unset
- exit
- pipe --> eu nao sei se isso ja foi devidamente tratado
- ctrl + \ --> does nothing
- heredoc
- expansions --> $xxx
- $? -->  expand to the exit status of the most recently
- '<'--> infile
- Lidar com erros e respectivas mensagens
- limpar os leaks e still reachable

Na verdade, a melhor ordem para que eu desenvolva esse trabalho
seria terminar o export e apartir dai fazer a expansao. Por fim,
fazer o unset. Pois assim eu poderei alterar o conteudo das varia-
veis de ambiente e depois usa-las dentro das minhas expansoes.

	O export possui o seguinte comportamento.
	Contudo, deverei observar que a expansao so ocorrera entre
double quotes. Dessa forma, quando estiver a percorrer a string
original, poderei indicar em uma flag se eh o caso de double quotes.
	Dentro do Parsing ja ha um counter de double quotes. Caso a flag seja
diferente de 0, a expansao devera funcionar. Portanto aqui deveremos ser
condizente, caso auto completemos as aspas deveremos fazer a expansao
ainda assim.
	Export sem argumentos apenas imprimi toda a env em ordem alfabetica e
com o declare x- na frente.
	Export com argumento apenas atualiza a variavel de ambiente respectiva
ou a cria caso nao exista. Mas nao imprimi o resultado.

*Alterei o ft_strlen para que ele receba uma string e um caracter set, Pois
assim ele ja retornara o length de um caracter dentro de uma string. Claramente,
caso seja do nosso interesse.
ft_strlen(char *str, char set);

	Para fazer a expansao precisarei percorrer o argumento e
dentro dele detectar o '$' os chars que vierem depois dele
precisarao ser encontrados dentro do nosso env.
Caso exista o conteudo da variavel do env devera substituir
o $ e seu conteudo.
	Portanto, deverei alocar memoria para o tamanho do meu arg
menos o $ e os chars continuos a ele. Depois perceber o ta-
manho do valor do correspondente aquele valor. Com isso poderei
alocar memoria para entao criar um novo argumento que sera
deverei liberar a memoria do argumento.


//    se o argumento do export nao existir no env teremos de criar um novo topico
// dentro de env.
//    se o argumento do export existir no env teremos de alterar o valor com o
// valor poisterior ao '=';
//    se o export nao tiver nenhum argumento precisaremos retornar o env em ordem
// alfabetica e com o declare -x antes das variaveis.

// Export sem argumentos apenas imprimi toda a env em ordem alfabetica e
//com o declare x- na frente.
// Export com argumento apenas atualiza a variavel de ambiente respectiva
//ou a cria caso nao exista. Mas nao imprimi o resultado.


Dia 16 de Maio de 2023
Mandar e-mail para o Pedro: pbc@42lisboa.com;

O Rodrigo reparou que a nossa regra de execucao nao esta completamente certa.
Por exemplo:
Quando executamos a seguinte linha de comando:
$ cat infile > outfile
--> A execucao corre bem e o conteudo do infile eh
empurrado para o outfile.
Contudo quando invertemos a ordem, o que nao faz diferenca para o bash,
deixa a nossa execucao em pausa aguardando travada. Eu acredito que o programa
fique a aguardar o outfile. Entretanto, nao estou totalmente certo disso.
$ > outfile cat infile
Em teste percebi que o programa fica a aguardar a escrita. Eu nao consigo perceber
bem mas acho que caso nao recebamos o infile na execucao, teremos de usar o O_TRUNC
e retornar o prompt. Apenas realizando o close em no fd aberto.

Talvez a solucao de tudo esteja em voltar ao parse e alterar a forma como construo
os comandos. Para que a construcao dos meus argumentos seja feita na mao. Vou criar
3 listas uma de comandos, uma de infiles e outra de outfile que ficara dentro da minha global.
Vou percorrer a minha lista de comandos, quando encontrar um outfile crio um novo node que
ira alterar outra variavel dentro da minha global. Quando encontrar um infile criarei uma novo
node na lista infile. Quando for criar meus comandos de execucao vou usar o infile e o outfile
da minha global.
Meus comandos serao executados em outra momento usando os infile e outifile dentro da minha global.

Quanto ao export ha algumas outras coisas a serem feitas. Como, por exemplo,
o "declare -x" e o fato dos valores dentro das variaveis virem entre double quotes.
Dessa forma, vou seguir os conselhos do Vasco e vou criar uma nova variavel dentro
da minha struct global. Assim poderei criar todo o export em uma bloco diferente.
*Quanto a ordenacao alfabetica teremos de comparar cada um dos elementos com todos os
demais elementos da lista a seguir dele. Por exemplo: o primeiro com o segundo e em diante.
O segundo como terceiro e em diante. Dessa forma, a palavra com as letras de menor valor da
tabela ascii sera empurradas para cima a medida que o programa eh executado.
O Primeiro ficara em sua posicao e o elemento que ocupava essa posicao no array 2d sera copiado
para a antiga posicao do prime


- criar uma nova variavel dentro da minha struct global
- clonar a env para essa nossa variavel.

    se o argumento do export existir no env teremos de alterar o valor com o
valor poisterior ao '='; (O Vasco apontou que ha um erro no ft_strncmp, pois
elecompara o manor ate o =)

    se o argumento do export nao existir no env teremos de criar um novo topico
dentro de env.

    se o export nao tiver nenhum argumento precisaremos retornar o env em ordem
alfabetica e com o declare -x antes das variaveis.
	 Contudo, para evitar de termos de fazer MULTIPLAS alteracoes no env para
	 quando formos retornar o export. O Vasco sugeriu que criassemos um segundo
	 array bidimensional dentro da nossa variavel global. Assim poderiamos armazenar
	 o retorno do nosso export com suas peculiaridades e dentro do nosso env as coisas
	 como recebemos. Teremos de tomar atencao para caso tenhamos de alterar algo, pois
	 assim teremos de alterar em dois lugares.

	Export sem argumentos apenas imprimi toda a env em ordem alfabetica e
com o declare x- na frente.
	Export com argumento apenas atualiza a variavel de ambiente respectiva
ou a cria caso nao exista. Mas nao imprimi o resultado.
	Export so aceitara o '_' como elemento para criacao de variaveis.



Dia 17 de maio
Consegui ordenar as variaveis que recebemos no env alfabeticamente. Contudo, realizei
isso armazenando essas variaveis dentro de uma linked list. Isso quebrou tudo que havia
desenvolvido no export. O que nao foi demasiado danoso pois esse Builtin eh um cado corner case
e nao esta envolvido com atividades da execucao.
Tentei fazer o mesmo ao env e ao inves de armazena-lo dentro de um array bidimensional, coloca-lo
dentro de uma linked list. Contudo, isso nao foi possivel tendo em vista que as variaveis de ambiente
estao envolvidas em um array 2d e precisam estar no formade de array_2d.
Portanto, agora, dentro da minha variavel global, estou a guardar um pointer para o inicio da minha
linked list, que armazena as variaveis dentro do meu export, e uma variavel que armazena o meu env.
Para colocar o meu export em funcionamento novamente precisarei recriar minha variavel execute_export.

Para fazer isso:
--> Primeiro precisarei criar minha lista a partir das variaveis de ambiente e ordena a lista
criada. Isso sera armazenado na minha variavel global. Dessa forma, terei acesso a partir de
toda a aplicacao.
--> caso o export nao possua nenhum argumento, terei de percorrer a lista e printar os elementos armazenados.
Ou seja, fazer a funcao print_list funcionar como deve ser. (CHECK)
--> caso o export tenha argumento e esse argumento ja esteja contido dentro das variaveis deverei
alterar o valor dessa variavel para o constante do argumento.(CHECK)
--> caso o export tenha argumento e esse argumento nao esteja contido dentro das variaveis deverei
adicionar a variavel e o valor ao fim da lista. (CHECK)

Agora preciso:
- add as novas variaveis ou as alteracoes das existentes tambem ao env.
- Bloquear a criacao de variaveis com chars nao desejados.

Para fazer o Unset:
-->

*para pensar amanha no cd. Caso alteremos a pasta onde esta sendo executado o minishell
nossa variavel path dentro do env devera se alterada.

dia 18 de Maio
Estive a refazer o parsing com o Rodrigo. Foi um dia bue produtivo, porem
preciso terminar a atividade de hoje para que eu possa seguir em frente.

Agora, eu tenho uma link list composta de strings.
Posso contar o tamanho dessa minha lista dessa forma saberei
quantas strings terei dentro dos meus args. Depois percorrer
minha lista de tokens realizando um strdup para dentro da minha
lista de comandos.
Estou a ter dificuldades na hora de criar meus argumentos pois
estou a cria-los apartir do split de 2. Contudo, terei de esperar
os tokens serem fomados para depois recolher os argumentos.

Dia 19 de maio

Estou a conectar o parsing com a lista de tokens formada, com a formacao de
argumentos de comando e com a execucao.
Primeiramente, sao criados os tokens para que possamos executar as execucoes
e o restante serao os argumentos de comando. A partir dai, terei de percorrer
minha lista de tokens dentro de cada node da minha lista de comandos existente
, que contem a lista de tokens, com isso poderei construir meu array multidimen-
sional para a execucao.
A execucao existente recebera esse array e o executara como antes.


Dia 22 de Maio

Estou mesmo a acabar com a expansao e com o unset.
- Para o unset eu preciso apenas sincronizar a atuallizacao
do env com o expo. Precisarei apenas percorrer minha lista
e comparar a string em questao com a string variavel de cada
node. A primeira sera analisada antes do loop e depois analisarei
o restante. Assim, mantenho me no previous para poder apontar o
next do node em que estou para o next do next.

--> O meu export so cria as variaveis caso possua o '=' no nome;
--> Caso eu tente definir uma variavel, nao estou a conseguir usar
o meu unset. Pois, a minha variavel esta a ser introduzida sem o '='.

- Ja a expansao precisara de mais atencao. Ja consigo criar
a string com acrescimo do length do value da variavel encontrada.
Tambem, ja substitui o $ dentro da double quotes por 5. Entao, agora,
precisarei apenas percorrer a string e procurar pelo 5 e substituir
tanto o 5 quanto o valor pelo correspondente valor da variavel.

- Para fazer o heredoc terei de criar um loop infinito com a funcao
readline la dentro. Toda line criada pelo user sera tratada como devido.
Essa funcao so sera interrompida quando a palavra selecionada for igual a
line digitada pelo usuario. Apos isso, todo o ficheiro sera analisado a
procura do $, caso seja encontrado, sera substituido pelo valor da variavel
correspondente.


dia 23 de Maio de Noite
Teremos de fazer nossa execucao voltar a funcionar devidamente. Estive a
executar qualquer coisa com o pipe e nao esta como deve ser.
-> env | wc -l (apenas o env eh executado e nada do wc -l);

--> Estive a tentar recompor meu unset. Para que realize multiplas execucoes
e continue a operar. Contudo, ele esta a decrementar demasiado as minhas variaveis
globais. Portanto, precisarei perceber como a funcao destroy_row esta a se comportar arg.
Tendo em vista que tirei a busca por posicao e estou a iterar a compara nomes.

Dia 24 de Maio


--> Quando executo "echo ola > |" estou a ter segmentation fault. Precisarei fazer uma
verificacao dentro dos tokens. Caso, apos de uma redirecao nao seja encontrado uma palavra
devo retornar erro de sintaxe.
--> Quando estou a executar o env | wc -l minha variavel global esta a decrementar mais
do que devia.

Dia 25 de Maio


--> Perceber e perseguir onde esta a causara leaks de memoria dentro da execucao.
--> Quando estou a executar o env | wc -l minha variavel global esta a decrementar mais
do que devia.
--> Quando executo "echo ola > |" estou a ter segmentation fault. Precisarei fazer uma
verificacao dentro dos tokens. Caso, apos de uma redirecao seja encontrada outra redirecao
devo retornar um erro de sintaxe. (DONE)
--> refatorar a funcao de execucao;
--> CTRL + D esta a gerar um segmentation Fault
--> O HereDoc nao esta a deixar de expandir as variaveis quando usa o \" e \'

Dia 26 de Maio
- Export: --> Nao esta a acrescenter multiplas variaveis perfeitamente sempre;
          --> Quando estiver a percorrer uma lista de multiplas variaveis a que tiver problemas
		sera ignorada, porem o bash continuara a percorrer a lista a add ou atualizar as demais
		variaveis. (CHECK)
		--> As variaveis que irao para o exporte tambem precisam receber expansao. (CHECK)
- Unset: --> precisa decrementar as variaveis recebidas do terminal e tambem as que nos adicionamos
		multiplas vezes de forma consistente. (CHECK)
		--> Nao esta a decrementar multiplas variaveis bem. (CHECK)
- Heredoc: --> O delimiter tambem precisa receber expansao. Caso, possua quotes nao havera expansao nem do
		delimiter, nem do conteudo do heredoc. (CHECK)
			-->
-ECHO: --> esta a receber as flags como deve de ser (CHECK)



Dia 27 de Maio
- CTRL + D: --> Gera um segmentation fault. Acredito que tenhamos de limpar tudo que foi alocado, que sao:
			- Lista de comandos e cada um dos elementos.
			- Fds aberto em cada processo realizado.
			- Variavel globais que possuem memoria alocada. Atualmente, as unicas que preenchem esse requisito
			eh o export e o env.
- Exit      --> Nos teremos de encerrar o programa, limpar tudo que foi criado, alterar o status da aplicacao,
			lidar com qualquer argumento passado.
- Remove the PATH --> Nenhum programa deveria ser executado a nao ser que passemos o path /bin/echo, por exemplo.
			Estamos com um segmentation fault dentro da funcao build_cmds_list. Estamos a inserir o path de forma
			equivocada.

Nos temos de limpar
--> g_terminal.env;
--> g_terminal.expo;
--> g_terminal.path;
--> tokens
--> tokens->str


Dia 29 de Maio

Testes e Leaks que precisaremos melhorar
--> PWD esta a indicar leaks
--> Esse teste cd $HOME/Documents esta a indicar um erro de bash
--> Esse teste echo -n -n -nnnn -nnnnm esta a indicar leaks
--> Apenas indicando o $ esta a ter segmentation Fault
--> not_cmd bonjour > salut Nesse comando o minishell esta
a criar e a empurrar para o file salut a seguinte mensagem:
"command not found: not_cmd". Enquanto essa mensagem no bash
eh indicada no Terminal.
--> cat Makefile | grep pr | head -n 5 | cd test (mybin)
a mensagem de erro nao eh a mesma e nem o status code.
--> cat Makefile | grep pr | head -n 5 | cd test mesma mensagem,
porem o status code nao eh o mesmo;
--> cat Makefile | grep pr | head -n 5 | cat test mesma mensagem
e mesmo codigo
--> $bla --> Esta a indicar command not found quando na verdade
deveria apenas retornar o prompt.
--> Caso torne o line com uma linha vazia o minishell encerrara.
Isso por causa do CTRL + D no main.c.

--> sleep 5 | exit --> o minishell esta a encerrar automaticamente
quando na verdade deveria aguardar o tempo para sleep.

--> ; --> deveria retornar syntax error, quando esta a retornar
command not found.
--> env -i ./minishell --> Estamos a correr nosso minishell, porem
quando tentamos executar qualquer comando temos um SEGfault.


Compilei com o fsanitize=address
--> Caso inicie o minishell e corra o comando:
- echo ola > outfile --> O file sera alterado de forma adequada.
Contudo, caso repitamos o comando, nesse caso teremos leaks. Portanto,
acredito que o problema seja na destruicao das listas de comandos antigas.

--> O mesmo disposto em cima acontece com o append.
echo ola >> outfile --> Caso seja a primeira
execucao, nos nao teremos problema e o file sera alterado como devido. Contudo,
ja repeticao do comando as coisas comecam a correr mal.

--> cat << '$HOME' --> No expansion, parou no delimiter e nao detectou leaks. (CHECK)
--> cat << "$HOME" --> No expansion, parou no delimiter e nao detectou leaks. (CHECK)

--> cat << '$HOME' > outfile --> estamos a indicar bash: syntax error near
unexpected token 'newline'. Contudo, o suposto seria empurrar o conteudo do
heardoc para o file outfile e nao realizar expansoes.
Na verdade, acabei de compilar o echo ola << eof > outfile e nao recebi um
syntax error.

cat << 'eof' > outfile --> syntax error near unexpected token 'newline'
cat << $USER > outfile --> syntax error near unexpected token 'newline'

Portanto, posso perceber que apos as duplas redirecoes podemos receber algo
diferente de alphanumerico. Portanto, precisamos alargar esse range do que esta
a ser aceito.


--> ctrl + \ --> Acredito que nao deveriamos fazer
nada. Contudo estamos a escrever ^\. O minishell da gabi esta
a ter o mesmo comportamento. Portanto, deveremos verificar se esse eh
o comportamento padrao.
