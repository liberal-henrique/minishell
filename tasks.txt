dia 19 de Abril
echo "luiz Henrique " > test.txt | wc -l | ls
	1 -> dividir toda a command line em palavras separadas por
	espaco. Tendo em vista que ha a possibilidade de usarmos
	as aspas para indicar apenas um argumento, eu tive de
	contornar essa adversidade para poder usar o split e simplificar
	toda a tokentization.
	2 -> dividir a command line em cada pipeline que existir. Assim
	separei os comandos que existem. Cada pipeline divide o command line
	em dois commandos.

Tudo isso feito, eu tenho dois arrays bidimensionais com as informacoes
que recebi. Eu agora precisarei percorrer minha string novamente e identificar
quais palavras sao comandos e assinalar o tipo de comando.
Com o que sei atualmente eu posso criar um dicionario de todos os comandos
existentes e criar um codigo para cada um para que possa assinala-lo a um tipo.
Portanto, ja irei comecar a criar tipos. Isso ficara limitado em um array_2d.
Para isso posso usar as informacoes que tenho para criar uma linked_list.


dia 20 de Abril
Estive a conversar com o Ezequiel e recebi varias dicas, entre elas:
- dentro das strings que recebo da funcao criada com o separador '|'
a primeira palavra eh sempre ou um command ou um Builtin.
- Tendo feito a divisao de tudo em palavras e em comandos. Agora,
eu preciso separar o que tenho em comandos e em seus respectivos argumentos dentro
de um array bidimensional. Isso seria tokentizar minha string recebida na command
line.
- Depois criarei uma linked list com as respectivas informacoes "    char		**args;
char		*gpath; int		fd[2]; int		in_fd; int		out_fd;
 struct s_token	*next;
	Devo considerar tudo buscar por redirecoes;



*Sabendo que a primeira palavra de cada um dos nossos comandos eh um builtin ou um
command e, tendo em vista, que os nossos Builtins sao uma lista menor de itens podemos
criar um dicionario com nossos builtin. O que nao for builtin possivelmente sera um
comando. Caso tenhamos alguma palavras escrita de forma errada na nossa funcao que
fornece o path retornara um NULL caso nao encontre.

dia 24 de Abril (segunda-feira)
na ultima sexta investi em aprender como criar uma binary tree. Contudo, acredito que
deveria ter feito o trabalho mais simples e implementado o que discuti com o Ezequiel.
Depois disso, vale a pena eu implementar melhorias no projeto e ate ajudar o Rodrigo com
a parte de execucao. Assim, poderei aprender sobre ambas as partes e ver como ele desenvolve.
Basicamente, eu tenho a seguinte command line e consigo dividir os comandos.


$ echo "luiz Henrique " > test.txt | wc -l | ls -la

[
	[echo"luiz Henrique ">test.txt],
	[wc, -l],
	[ls, -la],
]

Portanto, vou percorrer as minhas strings caso em encontre um separador
terei de quebrar a string daquele ponto ate o proximo separador.
Meu problema esta a ser com o array 2d, pois terei de inserir uma nova string.
Dessa forma, sera necessario criar um novo array com as novas dimensoes.
Na verdade, estive a pensar que seria mais facil lidar com esses desafios dentro
de uma linked list. Assim poderia acrescentar um node de forma mais simples e poderia
fazer isso multiplas vezes.

[
	[echo, "luiz Henrique "],
	[>, test.txt],
	[wc, -l],
	[ls, -la],
]

Outra situacao eh que eu teria de criar um dicionario indicar ao Rodrigo se
estamos a tratar um comando ou um builtin na caso especifico. Contudo, antes de
dificultar resolverei a situacao de forma simples e depois posso acrescentar camadas
de complexidade a mais.
Posso resolver isso apenas com comparacao de strings.


Dia 26 de abril

echo"luiz Henrique "
> test.txt
Na verdade, isso devera ser dividido em dois comandos. Portanto, dois nodes diferentes.

dia 29 de Abril de 2023
Estou em um ponto no qual ja estou a receber os input do user e
tratar disso da forma que eh devida. Separei os comandos e os argumentos dos
comandos de modo que consegui organizar devidamente dentro de um array bidimensional.
Consegui tambem localizar o path de cada dos comandos e caso nao haja path especifico
repassei o recebido no env.
Minha ideia agora sera criar um array de inteiros com todos os comandos que estamos e
criar uma funcao que me retornara um tipo ou uma string de referencia.
    void *capitalCities = new_hasmap();

    HashMap(capitalCities)->put("England", "London");


Dia 01 de Maio
Percebi que estava a lidar de forma equivocada com as quotes. Estava a aceitar a correspondencia
e combinacao de single com double e virse e versa. Isso estava errado. Foi facil perceber onde
estava o erro. Na verdade, devia checar se o meu char set era igual ao caracter de analise. Desse
modo ele teria de ser igual para receber completar o par.
Percebi que estava a retornar o path errado tambem, pois caso o path da variavel de ambiente
seja apagada com o unset ele estava a retornar NULL. Quando deveria retornar o valor recebido como
parametro. Resolver isso foi simples, pois na funcao gpath deveria retornar uma string com o commando
recebido.

Dia 03 de maio
Ontem sai daqui com uma mensagem de erro bastante estranha. Aparentemente, a minha funcao
split e/ou a minha funcao ft_substring estao a ter problemas em acessar espacos nao per-
mitidos de memoria. Portanto, isolei cada uma e mesmo ontem pude perceber que meu erro
nao estava propriamente dito no split.
Sai daqui com a impressao de que havia outra coisa, pois em casos em que
eu nao inseria o caracter 3 ou 2 o meu split criava um array_2d sem
encontrar o separador target.
Preciso isolar a funcao substring e


Dia 04 de Maio

Estou a procurar still reachable

Dia 08 de Maio
Ainda estou com os still reachable. Contudo, desenvolve os
signals que conectam o ctrl + c e ctrl + d para encerrar
o programa e poder perceber se ha leaks ou se estamos a
a administrar tudo como deve ser.
Estou a realizar a limpeza de toda a minha lista quando
clico em ctrl + d. Portanto, deveria estar a limpar toda
a memoria alocada. Contudo, ha ainda 214 alocamentos que
nao deveriam estar la que estao a ser identificados.
A falar com um colega que ja terminou esse projeto, fiquei
sabendo que onde dermos exit teremos de limpar a memoria para
nao termos still reachable.

Dia 10 de Maio
Ficou acertado com o Rodrigo que eu trataria das expansoes
e do export e ele cuidaria do infile e do heredoc.

tasks para minishell




Mandar e-mail para o Pedro: pbc@42lisboa.com;
