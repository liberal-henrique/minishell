 dia 19 de Abril
echo "luiz Henrique " > test.txt | wc -l | ls
	1 -> dividir toda a command line em palavras separadas por
	espaco. Tendo em vista que ha a possibilidade de usarmos
	as aspas para indicar apenas um argumento, eu tive de
	contornar essa adversidade para poder usar o split e simplificar
	toda a tokentization.
	2 -> dividir a command line em cada pipeline que existir. Assim
	separei os comandos que existem. Cada pipeline divide o command line
	em dois commandos.

Tudo isso feito, eu tenho dois arrays bidimensionais com as informacoes
que recebi. Eu agora precisarei percorrer minha string novamente e identificar
quais palavras sao comandos e assinalar o tipo de comando.
Com o que sei atualmente eu posso criar um dicionario de todos os comandos
existentes e criar um codigo para cada um para que possa assinala-lo a um tipo.
Portanto, ja irei comecar a criar tipos. Isso ficara limitado em um array_2d.
Para isso posso usar as informacoes que tenho para criar uma linked_list.


dia 20 de Abril
Estive a conversar com o Ezequiel e recebi varias dicas, entre elas:
- dentro das strings que recebo da funcao criada com o separador '|'
a primeira palavra eh sempre ou um command ou um Builtin.
- Tendo feito a divisao de tudo em palavras e em comandos. Agora,
eu preciso separar o que tenho em comandos e em seus respectivos argumentos dentro
de um array bidimensional. Isso seria tokentizar minha string recebida na command
line.
- Depois criarei uma linked list com as respectivas informacoes "    char		**args;
char		*gpath; int		fd[2]; int		in_fd; int		out_fd;
 struct s_token	*next;
	Devo considerar tudo buscar por redirecoes;



*Sabendo que a primeira palavra de cada um dos nossos comandos eh um builtin ou um
command e, tendo em vista, que os nossos Builtins sao uma lista menor de itens podemos
criar um dicionario com nossos builtin. O que nao for builtin possivelmente sera um
comando. Caso tenhamos alguma palavras escrita de forma errada na nossa funcao que
fornece o path retornara um NULL caso nao encontre.

dia 24 de Abril (segunda-feira)
na ultima sexta investi em aprender como criar uma binary tree. Contudo, acredito que
deveria ter feito o trabalho mais simples e implementado o que discuti com o Ezequiel.
Depois disso, vale a pena eu implementar melhorias no projeto e ate ajudar o Rodrigo com
a parte de execucao. Assim, poderei aprender sobre ambas as partes e ver como ele desenvolve.
Basicamente, eu tenho a seguinte command line e consigo dividir os comandos.


$ echo "luiz Henrique " > test.txt | wc -l | ls -la

[
	[echo"luiz Henrique ">test.txt],
	[wc, -l],
	[ls, -la],
]

Portanto, vou percorrer as minhas strings caso em encontre um separador
terei de quebrar a string daquele ponto ate o proximo separador.
Meu problema esta a ser com o array 2d, pois terei de inserir uma nova string.
Dessa forma, sera necessario criar um novo array com as novas dimensoes.
Na verdade, estive a pensar que seria mais facil lidar com esses desafios dentro
de uma linked list. Assim poderia acrescentar um node de forma mais simples e poderia
fazer isso multiplas vezes.

[
	[echo, "luiz Henrique "],
	[>, test.txt],
	[wc, -l],
	[ls, -la],
]

Outra situacao eh que eu teria de criar um dicionario indicar ao Rodrigo se
estamos a tratar um comando ou um builtin na caso especifico. Contudo, antes de
dificultar resolverei a situacao de forma simples e depois posso acrescentar camadas
de complexidade a mais.
Posso resolver isso apenas com comparacao de strings.


Dia 26 de abril

echo"luiz Henrique "
> test.txt
Na verdade, isso devera ser dividido em dois comandos. Portanto, dois nodes diferentes.

dia 29 de Abril de 2023
Estou em um ponto no qual ja estou a receber os input do user e
tratar disso da forma que eh devida. Separei os comandos e os argumentos dos
comandos de modo que consegui organizar devidamente dentro de um array bidimensional.
Consegui tambem localizar o path de cada dos comandos e caso nao haja path especifico
repassei o recebido no env.
Minha ideia agora sera criar um array de inteiros com todos os comandos que estamos e
criar uma funcao que me retornara um tipo ou uma string de referencia.
    void *capitalCities = new_hasmap();

    HashMap(capitalCities)->put("England", "London");


Dia 01 de Maio
Percebi que estava a lidar de forma equivocada com as quotes. Estava a aceitar a correspondencia
e combinacao de single com double e virse e versa. Isso estava errado. Foi facil perceber onde
estava o erro. Na verdade, devia checar se o meu char set era igual ao caracter de analise. Desse
modo ele teria de ser igual para receber completar o par.
Percebi que estava a retornar o path errado tambem, pois caso o path da variavel de ambiente
seja apagada com o unset ele estava a retornar NULL. Quando deveria retornar o valor recebido como
parametro. Resolver isso foi simples, pois na funcao gpath deveria retornar uma string com o commando
recebido.

Dia 03 de maio
Ontem sai daqui com uma mensagem de erro bastante estranha. Aparentemente, a minha funcao
split e/ou a minha funcao ft_substring estao a ter problemas em acessar espacos nao per-
mitidos de memoria. Portanto, isolei cada uma e mesmo ontem pude perceber que meu erro
nao estava propriamente dito no split.
Sai daqui com a impressao de que havia outra coisa, pois em casos em que
eu nao inseria o caracter 3 ou 2 o meu split criava um array_2d sem
encontrar o separador target.
Preciso isolar a funcao substring e


Dia 04 de Maio

Estou a procurar still reachable

Dia 08 de Maio
Ainda estou com os still reachable. Contudo, desenvolve os
signals que conectam o ctrl + c e ctrl + d para encerrar
o programa e poder perceber se ha leaks ou se estamos a
a administrar tudo como deve ser.
Estou a realizar a limpeza de toda a minha lista quando
clico em ctrl + d. Portanto, deveria estar a limpar toda
a memoria alocada. Contudo, ha ainda 214 alocamentos que
nao deveriam estar la que estao a ser identificados.
A falar com um colega que ja terminou esse projeto, fiquei
sabendo que onde dermos exit teremos de limpar a memoria para
nao termos still reachable.

Dia 10 de Maio
Ficou acertado com o Rodrigo que eu trataria das expansoes
e do export e ele cuidaria do infile e do heredoc.

tasks para minishell
- export
- unset
- exit
- pipe --> eu nao sei se isso ja foi devidamente tratado
- ctrl + \ --> does nothing
- heredoc
- expansions --> $xxx
- $? -->  expand to the exit status of the most recently
- '<'--> infile
- Lidar com erros e respectivas mensagens
- limpar os leaks e still reachable

Na verdade, a melhor ordem para que eu desenvolva esse trabalho
seria terminar o export e apartir dai fazer a expansao. Por fim,
fazer o unset. Pois assim eu poderei alterar o conteudo das varia-
veis de ambiente e depois usa-las dentro das minhas expansoes.

	O export possui o seguinte comportamento.
	Contudo, deverei observar que a expansao so ocorrera entre
double quotes. Dessa forma, quando estiver a percorrer a string
original, poderei indicar em uma flag se eh o caso de double quotes.
	Dentro do Parsing ja ha um counter de double quotes. Caso a flag seja
diferente de 0, a expansao devera funcionar. Portanto aqui deveremos ser
condizente, caso auto completemos as aspas deveremos fazer a expansao
ainda assim.
	Export sem argumentos apenas imprimi toda a env em ordem alfabetica e
com o declare x- na frente.
	Export com argumento apenas atualiza a variavel de ambiente respectiva
ou a cria caso nao exista. Mas nao imprimi o resultado.

*Alterei o ft_strlen para que ele receba uma string e um caracter set, Pois
assim ele ja retornara o length de um caracter dentro de uma string. Claramente,
caso seja do nosso interesse.
ft_strlen(char *str, char set);

	Para fazer a expansao precisarei percorrer o argumento e
dentro dele detectar o '$' os chars que vierem depois dele
precisarao ser encontrados dentro do nosso env.
Caso exista o conteudo da variavel do env devera substituir
o $ e seu conteudo.
	Portanto, deverei alocar memoria para o tamanho do meu arg
menos o $ e os chars continuos a ele. Depois perceber o ta-
manho do valor do correspondente aquele valor. Com isso poderei
alocar memoria para entao criar um novo argumento que sera
deverei liberar a memoria do argumento.


//    se o argumento do export nao existir no env teremos de criar um novo topico
// dentro de env.
//    se o argumento do export existir no env teremos de alterar o valor com o
// valor poisterior ao '=';
//    se o export nao tiver nenhum argumento precisaremos retornar o env em ordem
// alfabetica e com o declare -x antes das variaveis.

// Export sem argumentos apenas imprimi toda a env em ordem alfabetica e
//com o declare x- na frente.
// Export com argumento apenas atualiza a variavel de ambiente respectiva
//ou a cria caso nao exista. Mas nao imprimi o resultado.


Dia 16 de Maio de 2023
Mandar e-mail para o Pedro: pbc@42lisboa.com;

O Rodrigo reparou que a nossa regra de execucao nao esta completamente certa.
Por exemplo:
Quando executamos a seguinte linha de comando:
$ cat infile > outfile
--> A execucao corre bem e o conteudo do infile eh
empurrado para o outfile.
Contudo quando invertemos a ordem, o que nao faz diferenca para o bash,
deixa a nossa execucao em pausa aguardando travada. Eu acredito que o programa
fique a aguardar o outfile. Entretanto, nao estou totalmente certo disso.
$ > outfile cat infile
Em teste percebi que o programa fica a aguardar a escrita. Eu nao consigo perceber
bem mas acho que caso nao recebamos o infile na execucao, teremos de usar o O_TRUNC
e retornar o prompt. Apenas realizando o close em no fd aberto.

Talvez a solucao de tudo esteja em voltar ao parse e alterar a forma como construo
os comandos. Para que a construcao dos meus argumentos seja feita na mao. Vou criar
3 listas uma de comandos, uma de infiles e outra de outfile que ficara dentro da minha global.
Vou percorrer a minha lista de comandos, quando encontrar um outfile crio um novo node que
ira alterar outra variavel dentro da minha global. Quando encontrar um infile criarei uma novo
node na lista infile. Quando for criar meus comandos de execucao vou usar o infile e o outfile
da minha global.
Meus comandos serao executados em outra momento usando os infile e outifile dentro da minha global.

Quanto ao export ha algumas outras coisas a serem feitas. Como, por exemplo,
o "declare -x" e o fato dos valores dentro das variaveis virem entre double quotes.
Dessa forma, vou seguir os conselhos do Vasco e vou criar uma nova variavel dentro
da minha struct global. Assim poderei criar todo o export em uma bloco diferente.
*Quanto a ordenacao alfabetica teremos de comparar cada um dos elementos com todos os
demais elementos da lista a seguir dele. Por exemplo: o primeiro com o segundo e em diante.
O segundo como terceiro e em diante. Dessa forma, a palavra com as letras de menor valor da
tabela ascii sera empurradas para cima a medida que o programa eh executado.
O Primeiro ficara em sua posicao e o elemento que ocupava essa posicao no array 2d sera copiado
para a antiga posicao do prime


- criar uma nova variavel dentro da minha struct global
- clonar a env para essa nossa variavel.

    se o argumento do export existir no env teremos de alterar o valor com o
valor poisterior ao '='; (O Vasco apontou que ha um erro no ft_strncmp, pois
elecompara o manor ate o =)

    se o argumento do export nao existir no env teremos de criar um novo topico
dentro de env.

    se o export nao tiver nenhum argumento precisaremos retornar o env em ordem
alfabetica e com o declare -x antes das variaveis.
	 Contudo, para evitar de termos de fazer MULTIPLAS alteracoes no env para
	 quando formos retornar o export. O Vasco sugeriu que criassemos um segundo
	 array bidimensional dentro da nossa variavel global. Assim poderiamos armazenar
	 o retorno do nosso export com suas peculiaridades e dentro do nosso env as coisas
	 como recebemos. Teremos de tomar atencao para caso tenhamos de alterar algo, pois
	 assim teremos de alterar em dois lugares.

	Export sem argumentos apenas imprimi toda a env em ordem alfabetica e
com o declare x- na frente.
	Export com argumento apenas atualiza a variavel de ambiente respectiva
ou a cria caso nao exista. Mas nao imprimi o resultado.
	Export so aceitara o '_' como elemento para criacao de variaveis.



Dia 17 de maio
Consegui ordenar as variaveis que recebemos no env alfabeticamente. Contudo, realizei
isso armazenando essas variaveis dentro de uma linked list. Isso quebrou tudo que havia
desenvolvido no export. O que nao foi demasiado danoso pois esse Builtin eh um cado corner case
e nao esta envolvido com atividades da execucao.
Tentei fazer o mesmo ao env e ao inves de armazena-lo dentro de um array bidimensional, coloca-lo
dentro de uma linked list. Contudo, isso nao foi possivel tendo em vista que as variaveis de ambiente
estao envolvidas em um array 2d e precisam estar no formade de array_2d.
Portanto, agora, dentro da minha variavel global, estou a guardar um pointer para o inicio da minha
linked list, que armazena as variaveis dentro do meu export, e uma variavel que armazena o meu env.
Para colocar o meu export em funcionamento novamente precisarei recriar minha variavel execute_export.

Para fazer isso:
--> Primeiro precisarei criar minha lista a partir das variaveis de ambiente e ordena a lista
criada. Isso sera armazenado na minha variavel global. Dessa forma, terei acesso a partir de
toda a aplicacao.
--> caso o export nao possua nenhum argumento, terei de percorrer a lista e printar os elementos armazenados.
Ou seja, fazer a funcao print_list funcionar como deve ser. (CHECK)
--> caso o export tenha argumento e esse argumento ja esteja contido dentro das variaveis deverei
alterar o valor dessa variavel para o constante do argumento.(CHECK)
--> caso o export tenha argumento e esse argumento nao esteja contido dentro das variaveis deverei
adicionar a variavel e o valor ao fim da lista. (CHECK)

Agora preciso:
- add as novas variaveis ou as alteracoes das existentes tambem ao env.
- Bloquear a criacao de variaveis com chars nao desejados.

Para fazer o Unset:
--> 

*para pensar amanha no cd. Caso alteremos a pasta onde esta sendo executado o minishell
nossa variavel path dentro do env devera se alterada.
